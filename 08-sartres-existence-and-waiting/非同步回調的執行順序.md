# 非同步回調的執行順序

在 JavaScript 的世界中，非同步回調的執行順序是一個重要的議題。尤其是在實際開發中，我們經常需要透過非同步的方式來處理各種耗時的操作，比如說網路請求、讀寫文件等。那麼，非同步回調的執行順序到底是怎麼樣的呢？讓我們一起來探討一下。

## 同步 VS 非同步

首先，我們需要了解同步和非同步的區別。同步指的是按照程式碼的順序依次執行，每一個操作都必須等待上一個操作完成後，才能進行下一個操作。而非同步則是不需要等待上一個操作完成，就可以進行下一個操作。

以下是一個簡單的同步程式碼範例：

```javascript
console.log('1');
console.log('2');
console.log('3');
```

當我們執行上面的程式碼時，1、2、3 將會按照順序依次輸出。

然而，當我們使用非同步回調時，情況就會變得不一樣。以下是一個簡單的非同步程式碼範例：

```javascript
console.log('1');
setTimeout(function() {
    console.log('2');
}, 0);
console.log('3');
```

當我們執行上面的程式碼時，輸出的結果將會是 1、3、2。這是因為 `setTimeout` 是一個非同步函式，即使延遲時間為 0，它也會等待所有的同步操作完成後，才會執行。

## Event Loop 和任務佇列

要理解非同步回調的執行順序，我們需要了解 JavaScript 的 Event Loop 和任務佇列。

JavaScript 的執行環境是單緒的，也就是說，它一次只能執行一個任務。但是，JavaScript 可以透過 Event Loop 和任務佇列來處理非同步任務。

當我們調用一個非同步函式時，JavaScript 會把該函式的回調函式放入任務佇列中，然後繼續執行下一個任務。當所有的同步任務都執行完成後，JavaScript 會從任務佇列中取出一個任務，並執行該任務的回調函式。這就是 Event Loop。

以下是一個簡單的 Event Loop 程式碼範例：

```javascript
console.log('1');
setTimeout(function() {
    console.log('2');
}, 0);
console.log('3');
setTimeout(function() {
    console.log('4');
}, 0);
console.log('5');
```

當我們執行上面的程式碼時，輸出的結果將會是 1、3、5、2、4。這是因為 `setTimeout` 的回調函式會被放入任務佇列中，等待所有的同步任務都執行完成後，才會按照順序執行。

## 結論

非同步回調的執行順序是一個相對複雜的議題，它需要我們理解 JavaScript 的 Event Loop 和任務佇列。在實際開發中，我們應該儘量避免依賴於非同步回調的執行順序，以避免出現難以預料的錯誤。