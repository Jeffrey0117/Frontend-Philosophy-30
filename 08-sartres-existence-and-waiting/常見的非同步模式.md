# JavaScript 非同步程式設計: 常見的非同步模式

在這個網路瞬息萬變的時代，作為一位前端工程師，我們需要面對的不僅僅是畫面設計與互動，更要能有效地處理資料的傳輸與處理。其中，非同步程式設計就是我們必須要掌握的一項重要技能。

## 什麼是非同步？

在 JavaScript 中，「非同步」指的是當我們向伺服器發送請求或執行一個耗時的操作時，我們不需要等待該操作完成，就可以繼續執行其他程式碼。這是因為 JavaScript 是單線程的，也就是說，在同一時間點，它只能做一件事情。

那麼，如何實現非同步呢？我們接下來就來看看幾種常見的非同步模式。

## Callback Function

首先，我們來看看最基本的非同步模式 —— Callback Function。在 JavaScript 中，函式可以作為參數傳遞，這就為我們提供了一種非同步的可能。

以下是一個簡單的範例，我們使用 `setTimeout` 來模擬異步操作：

```js
function asyncFunction(callback) {
  setTimeout(() => {
    callback('非同步操作完成')
  }, 2000)
}

asyncFunction((message) => {
  console.log(message)
})

console.log('我在非同步操作之後')
```

在這個範例中，`asyncFunction` 是一個非同步函式，它接受一個 callback 函式作為參數，並在 `setTimeout` 中呼叫它。當我們執行這段程式碼時，最先印出的將會是 "我在非同步操作之後"，然後是 "非同步操作完成"。這就是非同步的魔力！

## Promise

然而，當非同步操作變得越來越複雜，我們可能會面臨到所謂的 callback hell。這時，Promise 就可以派上用場了。

Promise 是一個代表非同步操作結果的對象，它有三種狀態：pending（初始狀態）、fulfilled（操作成功）、rejected（操作失敗）。Promise 提供了一種更直觀、更易於理解的方式來處理非同步操作。

以下是一個使用 Promise 的範例：

```js
let promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('非同步操作完成')
  }, 2000)
})

promise.then((message) => {
  console.log(message)
})

console.log('我在非同步操作之後')
```

在這個範例中，我們建立一個新的 Promise，並在 `setTimeout` 中呼叫 `resolve`。當 Promise 狀態變為 fulfilled 時，我們可以使用 `then` 方法來處理結果。同樣地，最先印出的將會是 "我在非同步操作之後"，然後是 "非同步操作完成"。

## Async/Await

最後，我們來看看最近非常受歡迎的非同步模式 —— Async/Await。

Async/Await 是一種基於 Promise 的語法糖，它讓我們可以用更接近同步程式碼的方式來處理非同步操作，從而讓程式碼更容易理解和維護。

以下是一個使用 Async/Await 的範例：

```js
function asyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('非同步操作完成')
    }, 2000)
  })
}

async function main() {
  let message = await asyncFunction()
  console.log(message)
  console.log('我在非同步操作之後')
}

main()
```

在這個範例中，我們使用 `await` 關鍵字來等待 Promise 的結果，並將結果賦值給變數 `message`。而 `await` 只能在 `async` 函式中使用。這次，最先印出的將會是 "非同步操作完成"，然後是 "我在非同步操作之後"。這就是 Async/Await 的魔力！

## 結語

在這篇文章中，我們學習了三種常見的非同步模式: Callback Function、Promise 與 Async/Await。希望透過這些範例，讓大家能更深入地理解非同步程式設計的概念與實踐。未來在開發過程中，我們就能更靈活地運用這些工具，來處理各種非同步操作，提升我們的產品性能與使用者體驗。