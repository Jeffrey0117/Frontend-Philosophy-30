# 笛卡兒的「我閉包故我在」

# 笛卡兒的「我閉包故我在」：從哲學角度理解程式中的閉包

我們都熟知笛卡兒的那句格言「我思故我在」，他以此來確立自我存在的確實性。在程式設計的世界裡，我們可以透過類似的方式來理解閉包（Closure）：「我閉包故我在」。

## 閉包：程式中的笛卡兒哲學

閉包的概念，就如同笛卡兒的思想，是關於「存在」的問題。在程式中，一個函數的「存在」並不僅僅指他被定義的瞬間，還包括他如何持久地存在於記憶體裡，並保持對他所在作用域的參照。

如同笛卡兒所認為的，「我」的存在並不僅止於「我」的物理存在，而是「我」的思維。同理，一個函數的存在，並不只是他的程式碼，而是他對於他的外部環境的參照和記憶。這就是閉包。

## 作用域、詞法作用域與記憶體管理

在程式語言中，作用域是一個重要的概念。它決定了變數和函數的可見度和生存期。詞法作用域（lexical scope）則是一種作用域規則，它以程式碼的實際結構決定變數的作用範圍，而不是在運行時的狀態。

閉包的出現，則是作用域、詞法作用域和記憶體管理的完美結合。當一個函數能夠記住並訪問他的詞法作用域，即使當函數在該作用域外部被執行，那麼我們就稱這個函數為閉包。

## 如何使用閉包解決實際問題

閉包的一個重要應用是實現私有變數。在許多程式語言中，我們無法直接創造私有變數，但我們可以透過閉包來模擬私有變數，保護變數不被外部作用域訪問或修改。

例如，在 JavaScript 語言中，我們可以這麼做：

```javascript
function outer() {
    let privateVar = "I'm private";
    return function inner() {
        console.log(privateVar);
    }
}

let closureFunc = outer();
closureFunc();  // 輸出 "I'm private"
```

在這個例子中，`inner()` 函數是一個閉包，它可以訪問到 `outer()` 函數內的 `privateVar` 變數，即使 `inner()` 在 `outer()` 函數作用域之外被調用。

## 結語：哲學與技術的對話

閉包，就如同笛卡兒的「我思故我在」，是對「存在」的一種深度思考。在程式設計中，我們不只是創造出代碼，我們也在創造出一種持久的存在，一種能夠隨著時間流逝而保持連續性的存在。

這種存在，就是閉包。當我們寫出一個函數，並讓它記住自己的作用域，我們就實現了一種笛卡兒式的存在：「我閉包故我在」。