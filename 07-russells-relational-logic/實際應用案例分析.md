# 實際應用案例分析：事件代理模式解析

在前端開發中，事件代理模式是一種常見的設計模式，它可以讓我們以更有效率的方式來處理事件。在這篇文章中，我們會透過實際的程式碼範例來深入了解事件代理模式的運作原理，並探討其在實際應用中的優點。

## 事件代理模式的基本概念

首先，我們必須先理解什麼是事件代理模式。

事件代理模式是一種利用事件冒泡的概念，將內部事件的處理器委派給外部的父元素，而不是直接綁定在實際的事件目標上。這樣做的好處是減少事件處理器的數量，並且可以動態添加或移除子元素，而無需改變事件處理器。

```javascript
// 範例程式碼
var parent = document.querySelector('#parent');

parent.addEventListener('click', function (event) {
    if (event.target.tagName.toLowerCase() === 'li') {
        // 處理點擊事件
        console.log('Li element clicked');
    }
});
```

在這個範例中，我們在 `#parent` 元素上添加了一個 click 事件處理器。當點擊事件發生時，事件處理器會檢查事件目標是否為 `li` 元素，如果是，則執行相應的事件處理。

## 實際應用案例

接下來，讓我們看一個實際的應用案例，來展示事件代理模式的優勢。

假設我們有一個任務列表，每個任務都是一個 `li` 元素，並且我們希望當點擊任務時，可以將該任務標記為已完成。如果不使用事件代理模式，我們可能會這樣做：

```javascript
// 範例程式碼
var tasks = document.querySelectorAll('.task');

tasks.forEach(function (task) {
    task.addEventListener('click', function () {
        task.classList.toggle('completed');
    });
});
```

這樣的實現方式有一個問題：每次我們添加或移除任務時，都需要更新事件處理器。

但是，如果我們使用事件代理模式，我們就可以只在父元素上添加一個事件處理器：

```javascript
// 範例程式碼
var taskList = document.querySelector('#taskList');

taskList.addEventListener('click', function (event) {
    if (event.target.classList.contains('task')) {
        event.target.classList.toggle('completed');
    }
});
```

在這個範例中，我們只需要在 `#taskList` 元素上添加一個 click 事件處理器。當點擊事件發生時，事件處理器會檢查事件目標是否包含 `task` 類別，如果是，則切換 `completed` 類別。這樣，我們就可以動態添加或移除任務，而無需改變事件處理器。

## 總結

事件代理模式是一種強大且靈活的設計模式，它使我們能夠以更有效率的方式處理事件。透過事件代理，我們可以減少事件處理器的數量，並且可以動態添加或移除子元素，而無需改變事件處理器。

希望這篇文章能讓你對事件代理模式有更深入的理解，並能在你的下一個前端開發項目中派上用場。